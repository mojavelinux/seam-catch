<?xml version="1.0" encoding="UTF-8"?>
<!--
  JBoss, Home of Professional Open Source
  Copyright [2010], Red Hat, Inc., and individual contributors
  by the @authors tag. See the copyright.txt in the distribution for a
  full listing of individual contributors.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
<chapter id="client_usage">
   <title>Usage</title>

   <section id="client_usage.handlers">
      <title>Exception handlers</title>

      <para>
         As an application developer (i.e., an end user of Catch), you'll be focused on writing exception handlers. An
         exception handler is a method on a CDI bean that is invoked to handle a specific type of exception. Within that
         method, you can implement any logic necessary to handle or respond to the exception.
      </para>

      <para>
         Given that exception handler beans are CDI beans, they can make use of dependency injection, be scoped, have
         interceptors or decorators and any other functionality available to CDI beans.
      </para>
         
      <para>
         Exception handler methods are designed to follow the syntax and semantics of CDI observers, with some special
         purpose exceptions explained in this guide. The advantage of this design is that exception handlers will be
         immediately familiar to you if you are studying or well-versed in CDI.
      </para>

      <para>
         In this chapter, you'll learn how to define an exception handler and explore how and when it gets invoked. We'll
         begin by covering the two annotations that are used to declare an exception handler,
         <literal>@HandlesExceptions</literal> and <literal>@Handles</literal>.
      </para>
   </section>

   <section id="client_usage.annotations">
      <title>Exception handler annotations</title>

      <para>
         Exception handlers are contained within exception handler beans, which are CDI beans annotated with
         <literal>@HandlesExceptions</literal>. Exception handlers are methods whose first parameter is an instance of
         <literal>CaughtException&lt;T extends Throwable&gt;</literal> annotated with the <literal>@Handles</literal>
         annotation.
      </para>
         
      <section id="client_usage.handles_exceptions">
         <title>@HandlesExceptions</title>

         <para>
            The <literal>@HandlesException</literal> annotation is simply a marker annotation that instructs the Seam
            Catch CDI extension to scan the bean for handler methods.
         </para>

         <para>
            Let's designate a CDI bean as an exception handler by annotating it with
            <literal>@HandlesException</literal>.
         </para>

         <programlisting role="JAVA"><![CDATA[@HandlesExceptions
public class MyHandlers {}]]>
         </programlisting>

         <para>
            That's all there is to it. Now we can begin defining exception handling methods on this bean.
         </para>

         <para>
            <note>The <literal>@HandlesExceptions</literal> annotation may be deprecated in favor of annotation indexing
            done by <ulink href="http://seamframework.org/Seam3/Solder">Seam Solder</ulink>.</note>
         </para>
      </section>

      <section id="client_usage.handles">
         <title>@Handles</title>
         <para>
            <literal>@Handles</literal> is a method parameter annotation that designates a method as an exception
            handler. Exception handler methods are registered on beans annotated with
            <literal>@HandlesExceptions</literal>. Catch will discover all such methods at deployment time.
         </para> 

         <para>
            Let's look at an example. The following method is invoked for every exception that Catch processes and
            prints the exception message to stout. (<literal>Throwable</literal> is the base exception type in Java and
            thus represents all exceptions).
         </para>

         <programlistingco>
            <areaspec>
               <area id="handles-exceptions" coords="1"/>
               <area id="handles" coords="4"/>
               <area id="caught-exception-usage" coords="7"/>
               <area id="proceed" coords="8"/>
            </areaspec>
            <programlisting role="JAVA"><![CDATA[@HandlesExceptions
public class MyHandlers
{
   void printExceptions(@Handles CaughtException<Throwable> evt)
   {
      System.out.println("Something bad happened: " +
            evt.getException().getMessage());
      evt.proceed();
   }
}]]>
            </programlisting>
            <calloutlist>
               <callout arearefs="handles-exceptions">
                  <para>
                     The <literal>@HandlesExceptions</literal> annotation signals that this bean contains exception
                     handler methods.
                  </para>
               </callout>
               <callout arearefs="handles">
                  <para>
                     The <literal>@Handles</literal> annotation on the first parameter designates this method as an
                     exception handler. This parameter must be of type <literal>CaughtException&lt;T extends
                     Throwable&gt;</literal>, otherwise it's detected as a definition error. The type parameter
                     designates which exception the method should handle. This method is notified of all exceptions
                     (requested by the base exception type <literal>Throwable</literal>).
                  </para>
               </callout>
               <callout arearefs="caught-exception-usage">
                  <para>
                     The <literal>CaughtException</literal> instance provides access to information about the exception
                     and can be used to control exception handling flow. In this case, it's used to read the current
                     exception being handled in the exception stack trace, as returned by
                     <literal>getException()</literal>.
                  </para>
               </callout>
               <callout arearefs="proceed">
                  This handler does not modify the invocation of subsequent handlers, as designated by invoking
                  <literal>proceed()</literal> on <literal>CaughtException</literal>. As this is the default behavior,
                  this line could be omitted.
               </callout>
            </calloutlist>
         </programlistingco>

         <para>
            The <literal>@Handles</literal> annotation must be placed on the first parameter of the method, which must
            be of type <literal>CaughtException&lt;T extends Throwable&gt;</literal>. Handler methods are similar to CDI
            observers and, as such, follow the same principals and guidelines as observers (such as invocation,
            injection of parameters, qualifiers, etc) with the following exceptions:
         </para>

         <itemizedlist>
            <listitem>the first parameter of a handler method must be a <literal>CaughtException</literal></listitem>
            <listitem>handlers are ordered before they are invoked (invocation order of observers is non-deterministic)</listitem>
            <listitem>any handler can prevent subsequent handlers from being invoked</listitem>
         </itemizedlist>

         <para>
            In addition to designating a method as exception handler, the <literal>@Handles</literal> annotation
            specifies two pieces of information about when the method should be invoked relative to other handler
            methods:
         </para>

         <itemizedlist>
            <listitem>
               a precedence relative to other handlers for the same exception type. Handlers with higher precendence are
               invoked before handlers with lower precendence that handle the same exception type. The default
               precendence (if not specified) is 0.
            </listitem>
            <listitem>
               the direction of the traversal path (i.e., phase) during which the handler is invoked. The default
               traversal direction (if not specified) is <literal>TraversalPath.ASCENDING</literal>.
            </listitem>
         </itemizedlist>

         <para>
            Let's take a look at more sophisticated example that uses all the features of handlers to log all exceptions.
         </para>

         <programlistingco>
            <areaspec>
               <area id="handles-exceptions" coords="1"/>
               <area id="traversal" coords="4"/>
               <area id="qualifier" coords="5"/>
               <area id="injection" coords="6"/>
            </areaspec>
            <programlisting role="JAVA"><![CDATA[@HandlesExceptions
public class MyHandlers
{
   void logExceptions(@Handles(during = TraversalPath.DESCENDING)
         @WebRequest CaughtException<Throwable> evt,
         Logger log)
   {
      log.warn("Something bad happened: " + evt.getException().getMessage());
   }
}]]>
            </programlisting>
            <calloutlist>
               <callout arearefs="handles-exceptions">
                  <para>
                     The <literal>@HandlesExceptions</literal> annotation signals that this bean contains exception
                     handler methods.
                  </para>
               </callout>
               <callout arearefs="traversal">
                  <para>
                     This handler has a default precedence of 0 (the default value of the precedence attribute on
                     <literal>@Handles</literal>). It's invoked during the descending traversal path. For more
                     information on traversal, see the section <xref linkend="client_usage.handler_ordering.hierarchy_traversal"/>.
                  </para>
               </callout>
               <callout arearefs="qualifier">
                  <para>
                     This handler is qualified with <literal>@WebRequest</literal>. When Catch calculates the handler
                     chain, it filters handlers based on the exception type and qualifiers. This handler will only be
                     invoked for exceptions passed to Catch that carry the <literal>@WebRequest</literal> qualifier.
                     We'll assume this qualifier distinguishes a web page request from a REST request.
                  </para>
               </callout>
               <callout arearefs="injection">
                  <para>
                     Any additional parameters of a handler method are treated as injection points. These parameters are
                     injected into the handler when it is invoked by Catch. In this case, we are injecting a
                     <literal>Logger</literal> bean that must be defined within the application (or by an extension).
                  </para>
               </callout>
            </calloutlist>
         </programlistingco>

         <para>
            A handler is guaranteed to only be invoked once per exception (automatically muted), unless it reenables
            itself by invoking the <literal>unMute()</literal> method on the <literal>CaughtException</literal>
            instance.
         </para>
         
         <para>
            Handlers must not throw checked exceptions, and should avoid throwing unchecked exceptions.
         </para>
      </section>

   </section>

   <section id="client_usage.exception_stack">
      <title>Exception stack trace processing</title>

      <para>
         When an exception is thrown, chances are it's nested (wrapped) inside other exceptions. (If you've ever
         examined a server log, you'll appreciate this fact). The collection of exceptions in its entirety is termed an
         exception stack trace.
      </para>
      
      <para>
         The outermost exception of an exception stack trace (e.g., EJBException, ServletException, etc) is probably of
         little use to exception handlers.  That's why Catch doesn't simply pass the exception stack trace directly to
         the exception handlers. Instead, it intelligently unwraps the stack trace and treats the root exception cause
         as the primary exception.
      </para>
      
      <para>
         The first exception handlers to be invoked by Catch are those that match the type of root cause. Thus, instead
         of seeing a vague <literal>EJBException</literal>, your handlers will instead see an meaningful exception such
         as <literal>ConstraintViolationException</literal>. <emphasis>This feature, alone, makes Catch a worthwhile
         tool.</emphasis>
      </para>

      <!-- a graphic of layers (like rings) would be good here -->
      
      <para>
         Catch continues to work through the exception stack trace, notifying handlers of each exception in the stack,
         until a handler flags the exception as handled. Once an exception is marked as handled, Catch stops processing
         the exception. If a handler instructed Catch to rethrow the exception (by invoking
         <literal>CaughtException#rethrow()</literal>, Catch will rethrow the exception outside the Catch
         infrastructure. Otherwise, it simply returns flow control to the caller.
      </para>

      <para>
         Consider a stack trace containing the following nested causes (from outer cause to root cause):
      </para>

      <itemizedlist>
         <listitem>EJBException</listitem>
         <listitem>PersistenceException</listitem>
         <listitem>SQLGrammarException</listitem>
      </itemizedlist>

      <para>
         Catch will unwrap this exception and notify handlers in the following order:
      </para>

      <orderedlist>
         <listitem>SQLGrammarException</listitem>
         <listitem>PersistenceException</listitem>
         <listitem>EJBException</listitem>
      </orderedlist>

      <para>
         If there's a handler for <literal>PersistenceException</literal>, it will likely prevent the handlers for
         <literal>EJBException</literal> from being invoked, which is a good thing since what useful information can
         really be obtained from <literal>EJBException</literal>?
      </para>
   </section>

   <section id="client_usage.handler_ordering">
      <title>Exception handler ordering</title>

      <para>
         While processing one of the causes in the exception stack trace, Catch has a specific order it uses to invoke
         the handlers, operating on two axes:
      </para>

      <itemizedlist>
         <listitem>traversal of exception type hierarchy</listitem>
         <listitem>relative handler precedence</listitem>
      </itemizedlist>

      <para>
         We'll first address the traversal of the exception type hierarchy, then cover relative handler precedence.
      </para>

      <section id="client_usage.handler_ordering.hierarchy_traversal">
         <title>Traversal of exception type hierarchy</title>

         <para>
            Catch doesn't simply invoke handlers that match the exact type of the exception. Instead, it walks up and
            down the type hierarchy of the exception. It first notifies least specific handler, then gradually works
            down the type hiearchy towards handlers for the actual exception type. It then walks back up again towards
            the least specific handler.
         </para>

         <para>
            There are two phases of this traversal:
         </para>

         <itemizedlist>
            <listitem>ascending</listitem>
            <listitem>descending</listitem>
         </itemizedlist>

         <para>
            By default, handlers are registered into the ascending traversal path. That means in most cases, Catch
            starts with handlers of the actual exception type and works up towards the handler for the least specific type.
         </para>

         <para>
            However, when a handler is registered to be notified during the descending traversal, as in the example
            above, Catch will notify that exception handler before the exception handler for the actual type is
            notified.
         </para>

         <para>
            Let's consider an example. Assume that Catch is handling the <literal>SocketException</literal>. It will
            notify handlers in the following order:
         </para>

         <orderedlist>
            <listitem><literal>Throwable</literal></listitem>
            <listitem><literal>Exception</literal></listitem>
            <listitem><literal>IOException</literal></listitem>
            <listitem><literal>SocketException</literal></listitem>
            <listitem><literal>IOException</literal></listitem>
            <listitem><literal>Exception</literal></listitem>
            <listitem><literal>Throwable</literal></listitem>
         </orderedlist>

         <para>
            The same type traversal occurs for each exception processed in the stack trace.
         </para>

         <para>
            In order for a handler to be notified of the <literal>IOException</literal> before the
            <literal>SocketException</literal>, it would have to specify the descending traversal path explicitly:
         </para>

         <programlisting role="JAVA"><![CDATA[
void handleIOException(@Handles(during = TraversalPath.DESCENDING)
      CaughtException<IOException> evt)
{
   System.out.println("An I/O exception occurred, but not sure what type yet");
}]]>
         </programlisting>

         <para>
            Descending handlers are typically used for logging exceptions because they are not likely to be
            short-circuited (and thus always get invoked).
         </para>

      </section>

      <section id="precendence">
         <title>Handler precendence</title>

         <para>
            When Catch finds more than one handler for the same exception type, it orders the handlers by precendence.
            Handlers with higher precendence are executed before handlers with a lower precedence. If Catch detects two
            handlers for the same type with the same precedence, it detects it as an error and throws an exception at
            deployment time.
         </para>

         <para>
            Let's define two handlers with different precendence:
         </para>

         <programlisting role="JAVA"><![CDATA[
void handleIOExceptionFirst(@Handles(precendence = 100) CaughtException<IOException> evt)
{
   System.out.println("Invoked first");
}

void handleIOExceptionSecond(@Handles CaughtException<IOException> evt)
{
   System.out.println("Invoked second");
}]]>
         </programlisting>

         <para>
            The first method is invoked first since it has a higher precendence (100) than the second method, which has
            the default precedence (0).
         </para>

         <para>
            To make specifying precendence values more convenience, Catch provides several built-in constants, available
            on the <literal>Precedence</literal> interface:
         </para>

         <itemizedlist>
            <listitem>BUILT_IN = -100</listitem>
            <listitem>FRAMEWORK = -50</listitem>
            <listitem>DEFAULT = 0</listitem>
            <listitem>LOW = 50</listitem>
            <listitem>HIGH = 100</listitem>
         </itemizedlist>

      </section>

      <para>
         To summarize, here's how Catch determines the order of handlers to invoke (until a handler marks exception as
         handled):
      </para>

      <orderedlist>
         <listitem>Unwrap exception stack</listitem>
         <listitem>Begin processing root cause</listitem>
         <listitem>Find handler for least specific handler marked for descending traversal</listitem>
         <listitem>If multiple handlers for same type, invoke handlers with higher precendence first</listitem>
         <listitem>Continue above steps for each exception in stack</listitem>
         <listitem>Return to root cause</listitem>
         <listitem>Find handler for most specific handler marked for ascending traversal</listitem>
         <listitem>If multiple handlers for same type, invoke handlers with higher precendence first</listitem>
         <listitem>Continue previous two steps for each exception in stack</listitem>
      </orderedlist>

   </section>

   <section id="client_usage.api">
      <title>APIs for exception information and flow control</title>

      <para>
         There are two APIs provided by Catch that should be familiar to application developers:
      </para>

      <itemizedlist>
         <listitem>
            <literal>CaughtException</literal>
         </listitem>
         <listitem>
            <literal>ExceptionStack</literal>
         </listitem>
      </itemizedlist>

      <section id="client_usage.api.caughtexception">
         <title>CaughtException</title>

         <para>
            In addition to providing information about the exception being handled, the
            <literal>CaughtException</literal> object contains methods to control the exception handling process, such
            as rethrowing the exception, aborting the handler chain or unmuting the current handler.
         </para>

         <para>
            Five methods exist on the <literal>CaughtException</literal> object to give flow control to the handler
         </para>

         <itemizedlist>
            <listitem>
               <literal>abort()</literal>
               - terminate all handling immediately after this handler, does not mark the
               exception as handled, does not re-throw the exception.
            </listitem>
            <listitem>
               <literal>rethrow()</literal>
               - continues through all handlers, but once all handlers have been called
               (assuming another handler does not call abort() or handled()) the initial exception passed to Catch is
               rethrown. Does not mark the exception as handled.
            </listitem>
            <listitem>
               <literal>handled()</literal>
               - marks the exception as handled and terminates further handling.
            </listitem>
            <listitem>
               <literal>proceed()</literal>
               - default. Marks the exception as handled and proceeds with the rest of the
               handlers.
            </listitem>
            <listitem>
               <literal>proceedToCause()</literal>
               - marks the exception as handled, but proceeds to the next cause in
               the cause container, without calling other handlers for the current cause.
            </listitem>
         </itemizedlist>
         
         <para>
            Once a handler is invoked it is muted, meaning it will not be run again for that exception stack trace,
            unless it's explicitly marked as unmuted via the <literal>unmute()</literal> method on
            <literal>CaughtException</literal>.
         </para>

      </section>

      <section id="client_usage.api.stackinfo">
         <title>ExceptionStack</title>

         <para>
            <literal>ExceptionStack</literal> contains information about the exception causes relative to the current
            exception cause. It is accessed by calling the method <literal>getCauses()</literal> on the
            <literal>CaughtException</literal> object. Please see <ulink
            href="http://docs.jboss.org/seam/3/catch/latest/api/org/jboss/seam/exception/control/ExceptionStack.html">API
            docs</ulink> for more information, all methods are fairly self-explanatory.
         </para>
      </section>

   </section>

   <!--
   vim:et:ts=3:sw=3:tw=120
   -->
</chapter>
